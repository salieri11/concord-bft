/*
 * Copyright (c) 2019 VMware, Inc. All rights reserved. VMware Confidential
 */

package com.vmware.blockchain.configuration.generateconfig;

import java.io.BufferedWriter;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.yaml.snakeyaml.Yaml;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.MapperFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.vmware.blockchain.deployment.v1.ConcordModelSpecification.BlockchainType;

/**
 * Utility class for generating the input for Configuration Yaml file.
 */

public class ConcordConfigUtil {

    private static final Logger log = LoggerFactory.getLogger(ConcordConfigUtil.class);

    private String concordConfigTemplatePath;

    public ConcordConfigUtil(String concordConfigTemplatePath) {
        this.concordConfigTemplatePath = concordConfigTemplatePath;
    }

    /**
     * file path.
     */
    public static final String configPath = "/concord/config-local/concord.config";

    /**
     * persistence.
     */
    public final Map<Integer, List<Integer>> nodePrincipal = new HashMap<>();

    public int maxPrincipalId;

    /**
     * Utility to generate concord config.
     */
    public Map<String, String> getConcordConfig(List<String> nodeIds, List<String> hostIps,
                                                 BlockchainType blockchainType) {
        try {
            var result = new HashMap<String, String>();

            var outputPath = Files.createTempDirectory(null);
            var principalsMapFile = Paths.get(outputPath.toString(), "principals.json").toString();
            var inputYamlPath = Paths.get(outputPath.toString(), "dockerConfigurationInput.yaml").toString();

            generateInputConfigYaml(hostIps, inputYamlPath, blockchainType);

            var configFuture = new ProcessBuilder("/app/conc_genconfig",
                                                  "--configuration-input",
                                                  inputYamlPath,
                                                  "--report-principal-locations",
                                                  principalsMapFile)
                    .directory(outputPath.toFile())
                    .start()
                    .onExit();

            var work = configFuture.whenCompleteAsync((process, error) -> {
                if (error == null) {
                    try {
                        var principalStr = Files.readString(Path.of(principalsMapFile));
                        if (principalStr.isBlank() || principalStr.isEmpty()) {
                            throw new Exception("PrincipalIds are not generated by concord config");
                        }

                        TypeReference<Map<Integer, List<Integer>>> typeRef
                                = new TypeReference<>() {};

                        ObjectMapper objectMapper = new ObjectMapper();
                        objectMapper.configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true);
                        var principalsMap = objectMapper.readValue(principalStr, typeRef);
                        principalsMap.forEach((key, value) -> nodePrincipal.putIfAbsent(key - 1, value));


                        for (int num = 0; num < hostIps.size(); num++) {
                            var path = outputPath.resolve("concord" + (num + 1) + ".config");
                            result.put(nodeIds.get(num), Files.readString(path));
                        }
                    } catch (Throwable collectError) {
                        log.error("Cannot collect generated cluster configuration",
                                  collectError);
                    }
                } else {
                    log.error("Cannot run config generation process", error);
                }
            });

            work.join();
            return result;

        } catch (IOException e) {
            log.error("Exception while generating concord config {}", e.getLocalizedMessage());
            return null;
        }
    }

    /**
     * Utility method for generating input config yaml file.
     */
    boolean generateInputConfigYaml(List<String> hostIps, String configYamlPath,
                                    BlockchainType blockchainType) {
        if (!ConfigUtilHelpers.validateSbft(hostIps)) {
            return false;
        }
        int clusterSize = hostIps.size();
        int fVal = ConfigUtilHelpers.getFVal(clusterSize);
        int cVal = ConfigUtilHelpers.getCVal(clusterSize, fVal);
        return generateInputConfigYaml(hostIps, fVal, cVal, configYamlPath, blockchainType);
    }

    /**
     * Utility method for generating input config yaml file.
     */
    @SuppressWarnings({"unchecked"})
    boolean generateInputConfigYaml(List<String> hostIp, int fVal, int cVal, String configYamlPath,
                                    BlockchainType blockchainType) {
        if (!ConfigUtilHelpers.validateSbft(hostIp, fVal, cVal)) {
            return false;
        }

        maxPrincipalId = (hostIp.size() + ConfigUtilHelpers.CLIENT_PROXY_PER_COMMITTER * hostIp.size()) - 1;

        Path path = Paths.get(configYamlPath);

        Yaml yaml = new Yaml();
        Map<String, Object> configInput;
        try {
            configInput = yaml.load(new FileInputStream(concordConfigTemplatePath));
        } catch (FileNotFoundException e) {
            // For unit tests only.
            log.warn("File {} does not exist: {}\n Using localized config yaml input template",
                    concordConfigTemplatePath, e.getLocalizedMessage());
            ClassLoader classLoader = getClass().getClassLoader();
            configInput = yaml.load(classLoader.getResourceAsStream("ConcordConfigTemplate.yaml"));
        }

        //FIXME: Add provision to have more than one BlockchainType
        if (blockchainType == null || blockchainType.equals(BlockchainType.ETHEREUM)) {
            configInput.put(ConfigUtilHelpers.ConfigProperty.ETHEREUM_ENABLED.name, true);

            // FIXME: for https://jira.eng.vmware.com/browse/VB-1925
            //  Remove once bug is fixed OR when remodeled to have per-blockchain config template
            configInput.put("FEATURE_time_service", false);
        } else if (blockchainType.equals(BlockchainType.DAML)) {
            configInput.put(ConfigUtilHelpers.ConfigProperty.DAML_ENABLED.name, true);
        } else if (blockchainType.equals(BlockchainType.HLF)) {
            configInput.put(ConfigUtilHelpers.ConfigProperty.HLF_ENABLED.name, true);
        }

        configInput.put(ConfigUtilHelpers.ConfigProperty.F_VAL.name, fVal);
        configInput.put(ConfigUtilHelpers.ConfigProperty.C_VAL.name, cVal);

        // Prepare per replica config
        List node = (List) configInput.get(ConfigUtilHelpers.ConfigProperty.NODE.name);
        Map<String, Object> nodeConfig = (Map<String, Object>) node.get(0);

        //FIXME: Concord to fix: Why is replica a list?
        List replicaConfig = (List) nodeConfig.get(ConfigUtilHelpers.ConfigProperty.REPLICA.name);
        Map<String, Object> replicaValues = (Map<String, Object>) replicaConfig.get(0);

        List clientConfig = (List) nodeConfig.get(ConfigUtilHelpers.ConfigProperty.CLIENT_PROXY.name);
        Map<String, Object> clientValues = (Map<String, Object>) clientConfig.get(0);

        List resultNodes = new ArrayList();

        for (String s : hostIp) {
            List resultClients = new ArrayList();
            replicaValues.put(ConfigUtilHelpers.ConfigProperty.REPLICA_HOST.name, s);

            for (int j = 0; j < ConfigUtilHelpers.CLIENT_PROXY_PER_COMMITTER; j++) {
                clientValues.put(ConfigUtilHelpers.ConfigProperty.CLIENT_HOST.name, s);
                clientValues.put(ConfigUtilHelpers.ConfigProperty.CLIENT_PORT.name,
                        ConfigUtilHelpers.DEFAULT_PORT + j + 1);
                resultClients.add(ConfigUtilHelpers.clone(clientValues));
            }

            nodeConfig.put(ConfigUtilHelpers.ConfigProperty.CLIENT_PROXY.name, resultClients);
            nodeConfig.put(ConfigUtilHelpers.ConfigProperty.REPLICA.name,
                    new ArrayList(Collections.singletonList(ConfigUtilHelpers.clone(replicaValues))));
            resultNodes.add(ConfigUtilHelpers.clone(nodeConfig));
        }

        configInput.put(ConfigUtilHelpers.ConfigProperty.NODE.name, resultNodes);

        try {
            BufferedWriter writer = Files.newBufferedWriter(path);
            yaml.dump(configInput, writer);
            writer.flush();
            writer.close();
            return true;
        } catch (IOException x) {
            log.error("IOException: %s%n", x);
            return false;
        }
    }
}
