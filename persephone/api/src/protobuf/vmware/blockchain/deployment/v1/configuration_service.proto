/* [START declaration] */
syntax = "proto3";
package vmware.blockchain.deployment.v1;

import "vmware/blockchain/deployment/v1/core.proto";
import "vmware/blockchain/deployment/v1/concord_model.proto";
import "vmware/blockchain/deployment/v1/security_identity.proto";
import "vmware/blockchain/ethereum/type/genesis.proto";

option go_package = "vmware.com/blockchain/deployment/v1;deployment";

/* [START java_declaration] */
option java_package = "com.vmware.blockchain.deployment.v1";
option java_multiple_files = true;
/* [END java_declaration] */

/* [START messages] */


/**
* Denotes the configuration component
*
* @param[type]
*  Type of the docker component
* @param[component_url]
*   String url where the component should reside
* @param[component]
*   String value of the component
* @param [identity_factors]
*   Algorithms and curves used if used
*   Note: this is only for testing purpose. In future, this could
*   be an input to generator to generate certain type of certs (RSA/EC)
*/
message ConfigurationComponent {
    ConcordComponent.ServiceType type = 1;
    string component_url = 2;
    string component = 3;
    IdentityFactors identity_factors = 4;
}

/**
 * Model definition for ConfigurationService request.
 *
 * @property[header]
 *   message header.
 * @property[hostIps]
 *   list of host ips for the cluster
 *  TODO: genesis should be sent via properties/node_properties
 */
message ConfigurationServiceRequest {
    MessageHeader header = 1;
    repeated string hosts = 2;
    ConcordModelSpecification.BlockchainType blockchain_type = 3;
    vmware.blockchain.ethereum.type.Genesis genesis = 4;
    repeated ConcordComponent.ServiceType services = 5 [packed=false];
    Properties properties = 6;
    repeated NodeProperty node_properties = 7;
}

/**
 * Denote the identifier of a configuration session.
 *
 * @property[identifier]
 *   integer identifier;
 */
message ConfigurationSessionIdentifier {
    int64 identifier = 1;
    string id = 2;
}

/**
* Denote the node configuration response
*
* @property[IdentityComponent]
*   list of IdentityComponent
*/
message NodeConfigurationResponse {
    repeated ConfigurationComponent configuration_component = 1;
}

/**
* Denote the node configuration request
*
* @property[identifier]
*   the session identifier
* @property[node]
*   the node id whose configuration is needed
*/
message NodeConfigurationRequest {
    MessageHeader header = 1;
    ConfigurationSessionIdentifier identifier = 2;
    int32 node = 3;
    string node_id = 4;
}

message NodesInfo {

    message Entry {
        string id = 1;
        NodeType type = 2;
        string node_ip = 3;
        repeated ConcordComponent.ServiceType services = 4 [packed=false];
        Properties properties = 5;
    }
    repeated Entry entries = 1 [packed=false];
}

message ConfigurationServiceRequestV2 {
    MessageHeader header = 1;
    string consortium_id = 2;
    string blockchain_id = 3;
    BlockchainType blockchain_type = 4;
    Properties generic_properties = 5;
    map<string, NodesInfo> nodes = 7;
}
/* [END messages] */


/* [START services] */
/**
 * Service definition pertaining to operations on Concord configurations.
 */
service ConfigurationService {
    /**
     * Operation to generate Tls key/certificate pairs for each node in a cluster
     * based on a [TlsConfigurationServiceRequest].
     */
    rpc CreateConfiguration (ConfigurationServiceRequest) returns (ConfigurationSessionIdentifier);

    /**
    * Operation to get node configuration for given node
    */
    rpc GetNodeConfiguration (NodeConfigurationRequest) returns (NodeConfigurationResponse);

    rpc CreateConfigurationV2 (ConfigurationServiceRequestV2) returns (ConfigurationSessionIdentifier);
}
/* [END services] */