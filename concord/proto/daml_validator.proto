// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
//
// DAML submission validation service
//

syntax = "proto3";
package com.digitalasset.kvbc;
option java_package = "com.digitalasset.kvbc";

import "google/protobuf/empty.proto";
import "google/protobuf/timestamp.proto";

// The validation service provides a gRPC API taking the `DamlSubmission` message, along
// with the inputs to the submission and returns the resulting fragments and state updates.
service ValidationService {
  rpc Validate (stream EventToValidator) returns (stream EventFromValidator) {}

  // Message flow:
  // Initial: Preprocessor -> Engine: PreexecutionRequest
  // Repeated (and possibly interleaved): Engine -> Preprocessor -> Engine: ReadRequest / ReadResult
  // Final: Engine -> Preprocessor: PreexecutionResult
  rpc Preexecute (stream PreprocessorToEngine) returns (stream PreprocessorFromEngine) {}
}

message ValidateRequest {
  bytes entry_id = 1;
  bytes submission = 2;
  google.protobuf.Timestamp record_time = 3;
  reserved 4; // was input_state
  string participant_id = 5;

  // The Concord replica that sent this message. Used to maintain separate
  // state caches on the validator for setups that use single validator for multiple
  // replicas (e.g. during development)
  int64 replica_id = 6;
  string correlation_id = 7;
  bytes span_context = 8;
}

message ProtectedKeyValuePair {
  bytes key = 1;
  bytes value = 2;

  // Thin replica ids to which this key-value pair is visible to.
  // If the list is empty, the key-value pair is publicly visible.
  // To only show the key-value pair to replica the list should contain
  // the replica's id.
  // FIXME(JM): What should we use as the replica's id?
  repeated string trids = 3;
}

message KeyValuePair {
  bytes key = 1;
  bytes value = 2;
}

// Event sent from the caller (e.g. Concord) towards the validator.
message EventToValidator {
  // A read result is the response to validator's `Read` event.
  message ReadResult {
    // Tag to match with the read event.
    string tag = 1;

    // The read key-value pairs.
    repeated KeyValuePair key_value_pairs = 2;
  }

  oneof to_validator {
    ValidateRequest validate_request = 1;
    ReadResult read_result = 2;
  }
}

// Event from the validator towards the caller.
message EventFromValidator {
  message Read {
    // Tag to match with the read result.
    string tag = 1;

    // Keys to read from KVB.
    repeated bytes keys = 2;
  }

  message Done {
    repeated bytes read_set = 1;
    // Key-value updates to write to KVB.
    repeated ProtectedKeyValuePair write_set = 2;
  }

  oneof from_validator {
    // Request to read data from KVB. Client responds with a ReadResult.
    // If an error occurs the client should close the stream to abort
    // the validation.
    Read read = 1;

    // Signal that the validation has completed, this is the last event on
    // the stream and it can be closed by the client now.
    Done done = 2;
  }
}

// Values are accompanied by a fingerprint. For a given key, the fingerprint identifies a value
// with overwhelming probability (e.g., unless a hash collision occurs).
// The fingerprint itself is determined by Concord;
// the DAML Commands Handler and the DAML Execution Engine treat it as opaque.
// Fingerprints are used as a shorthand for the values in the read set of the pre-execution result.
// If a key is not present in the KVBC, the KVBC should return a special fingerprint (different from all other ones).
//
// For illustration, a fingerprint can be the value itself, a hash of the value,
// or the block height at which the value was written.
// All fields are required.
message KeyValueFingerprintTriple {
  bytes key = 1;
  // If the value is empty, the key was not present in the KVBC.
  bytes value = 2;
  bytes fingerprint = 3;
}

message PreprocessorToEngine {
  oneof to_engine {
    PreExecutionRequest preexecution_request = 1;
    ReadResult read_result = 2;
  }

  message PreExecutionRequest {
    // The DAML submission to pre-execute
    bytes submission = 1;

    // The ID of the participant (= thin replica ID) that has submitted the DAML submission.
    string submitting_participant_id = 2;

    // The Concord replica that sent this message. Used to maintain separate
    // state caches on the DAML Execution Engine for setups that use a single validator for multiple
    // replicas (e.g. during development)
    int64 replica_id = 100;
    
    // Correlation-id to use in log messages emitted when processing this request.
    string correlation_id = 101;
    
    // OpenTracing span context
    bytes span_context = 102;
  }

  message ReadResult {
    // Tag to match with the read request
    string tag = 1;

    // The read keys, with their values and fingerprints.
    // There exists a block height at which the requested keys have the returned values (atomic reads).
    // This block height is at least the block height at which pre-execution started on the particular replica.
    //
    // Every replica chooses for each ReadRequest a block height of its own.
    // (Rocks DB provides atomic reads for individual requests out of the box
    // because all operations execute sequentially.)
    repeated KeyValueFingerprintTriple key_value_pairs = 2;
  }
}


message PreprocessorFromEngine {
  oneof from_engine {
    // Request data from the KV store
    // Every request is answered at some block height.
    // Different requests may be answered at different block heights.
    // A later read request may be answered at a block height that is lower than an earlier read request's.
    // For a consistent set of read values, the DAML Execution Engine should make only a single read request.
    ReadRequest read_request = 1;

    // The result of the pre-execution.
    //
    // The read_set contains all keys that this pre-execution request depends on,
    // along with the fingerprints of the values that were used.
    // Post-execution checks for conflicts on these keys using the fingerprints.
    // Keys are sorted in ascending order.
    //
    // The serialization may only depend on the following inputs:
    // - The key-value-fingerprint triples read during this pre-execution
    // - Key-value-fingerprint triples cached during earlier (pre-)executions
    // - The serialized DAML submission
    // - The submitting participant id
    // In particular, it must not depend on the following:
    // - The replica ID
    PreExecutionResult preexecution_result = 2;
  }

  message ReadRequest {
    // Tag to match with the read request
    // Tags must be unique within the stream of one Preexecute service call.
    string tag = 1;

    // The keys to be read.
    // Note that any keys that appear in the request whose KeyType is Event may be ignored.
    // Additionally, the lifetime of private state keys will not influence the result.
    repeated KeyAndType keys = 2;
  }

  message KeyAndType {
    bytes key = 1;
    KeyType key_type = 2;
  }
}

message PreExecutionResult {
  ReadSet read_set = 1;
  // Pre-execution output to be passed to post-execution.
  PreExecutionOutput output = 2;
  string request_correlation_id = 3;
}

message PreExecutionOutput {
  // The time bounds for the record time for the success write set to be written.
  //
  // The DAML Commands Handler checks during post-execution
  // whether the block's summarized time (from the time service)
  // lies within the given bounds (inclusive).
  // If the check fails, the out_of_time_bounds_write_set is written.
  google.protobuf.Timestamp min_record_time = 1;
  google.protobuf.Timestamp max_record_time = 2;

  // The write set to be written if the record time is within bounds (inclusive).
  WriteSet success_write_set = 3;

  // The write set to be written if the record time is outside of the bounds.
  WriteSet out_of_time_bounds_write_set = 4;

  // The thin replica clients ids that should learn about the transaction
  // if the success_write_set is written.
  //
  // Post-execution adds a key-value pair with the block's summarized time
  // (= record time) to the write set.
  // This key is visible to the informee_success_thin_replica_ids if the success_write_set is written.
  repeated string informee_success_thin_replica_ids = 5;

  // The block's summarized time is visible to the submitting_participant_id
  // if the out_of_time_bounds_write_set is written.
  //
  // This field is included in the pre-execution output
  // of the DAML Execution Engine
  // so that it makes it to post-execution.
  string submitting_participant_id = 6;
}

message KeyType {
  // Private state keys will have the ACL always set to private.
  message PrivateState {
    message Permanent { }
    oneof lifetime {
      // Permanent keys will be present in the state until manually deleted.
      Permanent permanent = 1;

      // Keys with an expiry will be present in the state until the expires_after time (as
      // measured by the TimeContract), unless manually deleted before.
      // Concord may delete the key at any time after the expiry time, but there is no time bound
      // on when the deletion must happen.
      google.protobuf.Timestamp expires_after = 2;
    }
  }

  // Provable state keys will always have a non-private ACL.
  message ProvableState { }

  // Events are only present in the block in which they're written.
  message Event { }

  oneof type {
    PrivateState private_state = 1;
    ProvableState provable_state = 2;
    Event event = 3;
  }
}

message KeyAndFingerprint {
  bytes key = 1;
  bytes fingerprint = 2;
}

message ReadSet {
  repeated KeyAndFingerprint keys_with_fingerprints = 1;
}

message WriteSet {
  // A write set is a sequence of key-value-access triples.
  repeated KeyValueAccessTriple writes = 1;
}

// Represents a key-value pair with an ACL. All fields are required.
message KeyValueAccessTriple {
  bytes key = 1;

  // If the value is empty, the key is to be deleted from the KVBC.
  // The value may only be empty for state keys (as specified by the KeyType);
  // for event keys, it must always be set to a non-empty value.
  bytes value = 2;

  // Its value is ignored if the key is to be deleted (the "value" field is empty).
  AccessControlList access = 3;

  KeyType key_type = 4;
}

message AccessControlList {
  message Restricted {
    repeated string participant_id = 1;
  }
  // Optional: if absent then the access is unrestricted (public). If present, it can still
  // contain an empty participant list, which means that no participants will see the associated
  // write set.
  Restricted restricted = 2;
}

// Contents of a time update entry, as expected by participant state reader in Ledger API Server
// for pre-executed submissions.
// Must mirror relevant field numbers from com.daml.ledger.participant.state.kvutils.DamlLogEntry.
message TimeUpdateLogEntry {
  google.protobuf.Timestamp record_time = 1;
  oneof payload {
    google.protobuf.Empty time_update_entry = 101;
  }
}
