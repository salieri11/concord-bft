// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
//
// DAML submission validation service
//

syntax = "proto3";
package com.digitalasset.kvbc;
option java_package = "com.digitalasset.kvbc";

import "google/protobuf/empty.proto";
import "google/protobuf/timestamp.proto";
import "concord.proto";

// The validation service provides a gRPC API taking the `DamlSubmission` message, along
// with the inputs to the submission and returns the resulting fragments and state updates.
service ValidationService {
  rpc Validate (stream EventToValidator) returns (stream EventFromValidator) {}

  // Message flow:
  // Initial: Preprocessor -> Engine: PreexecutionRequest
  // Repeated (and possibly interleaved): Engine -> Preprocessor -> Engine: ReadRequest / ReadResult
  // Final: Engine -> Preprocessor: PreexecutionResult
  rpc Preexecute (stream PreprocessorToEngine) returns (stream PreprocessorFromEngine) {}
}

message ValidateRequest {
  bytes entry_id = 1;
  bytes submission = 2;
  google.protobuf.Timestamp record_time = 3;
  reserved 4; // was input_state
  string participant_id = 5;

  // The Concord replica that sent this message. Used to maintain separate
  // state caches on the validator for setups that use single validator for multiple
  // replicas (e.g. during development)
  int64 replica_id = 6;
  string correlation_id = 7;
  bytes span_context = 8;
}

message ProtectedKeyValuePair {
  bytes key = 1;
  bytes value = 2;

  // Thin replica ids to which this key-value pair is visible to.
  // If the list is empty, the key-value pair is publicly visible.
  // To only show the key-value pair to replica the list should contain
  // the replica's id.
  // FIXME(JM): What should we use as the replica's id?
  repeated string trids = 3;
}

message KeyValuePair {
  bytes key = 1;
  bytes value = 2;
}

// Event sent from the caller (e.g. Concord) towards the validator.
message EventToValidator {
  // A read result is the response to validator's `Read` event.
  message ReadResult {
    // Tag to match with the read event.
    string tag = 1;

    // The read key-value pairs.
    repeated KeyValuePair key_value_pairs = 2;
  }

  oneof to_validator {
    ValidateRequest validate_request = 1;
    ReadResult read_result = 2;
  }
}

// Event from the validator towards the caller.
message EventFromValidator {
  message Read {
    // Tag to match with the read result.
    string tag = 1;

    // Keys to read from KVB.
    repeated bytes keys = 2;
  }

  message Done {
    repeated bytes read_set = 1;
    // Key-value updates to write to KVB.
    repeated ProtectedKeyValuePair write_set = 2;
  }

  oneof from_validator {
    // Request to read data from KVB. Client responds with a ReadResult.
    // If an error occurs the client should close the stream to abort
    // the validation.
    Read read = 1;

    // Signal that the validation has completed, this is the last event on
    // the stream and it can be closed by the client now.
    Done done = 2;
  }
}

// Values are accompanied by fingerprint. For a given key, the fingerprint identifies a value
// with overwhelming probability (e.g., unless a hash collision occurs).
// The fingerprint itself is determined by Concord;
// the DAML Commands Handler and the DAML Execution Engine treat it as opaque.
// Fingerprints are used as a shorthand for the values in the read set of the pre-execution result.
//
// For illustration, a fingerprint can be the value itself, a hash of the value,
// or the block height at which the value was written.
message KeyValueFingerprintTriple {
  bytes key = 1;
  bytes value = 2;
  bytes fingerprint = 3;
}

message PreprocessorToEngine {
  oneof to_engine {
    PreExecutionRequest preexecution_request = 1;
    ReadResult read_result = 2;
  }

  message PreExecutionRequest {
    // The DAML submission to pre-execute
    bytes submission = 1;

    // The ID of the participant (= thin replica ID) that has submitted the DAML submission.
    string submitting_participant_id = 2;

    // The Concord replica that sent this message. Used to maintain separate
    // state caches on the DAML Execution Engine for setups that use a single validator for multiple
    // replicas (e.g. during development)
    int64 replica_id = 100;
    
    // Correlation-id to use in log messages emitted when processing this request.
    string correlation_id = 101;
    
    // OpenTracing span context
    bytes span_context = 102;
  }

  message ReadResult {
    // Tag to match with the read request
    string tag = 1;

    // The read key-value pairs.
    // There exists a block height at which the requested keys have the returned values (atomic reads).
    // This block height is at least the block height at which pre-execution started on the particular replica.
    //
    // Every replica chooses for each ReadRequest a block height of its own.
    // (Rocks DB provides atomic reads for individual requests out of the box
    // because all operations execute sequentially.)
    repeated KeyValueFingerprintTriple key_value_pairs = 2;
  }
}


message PreprocessorFromEngine {
  oneof from_engine {
    // Request data from the KV store
    // Every request is answered at some block height.
    // Different requests may be answered from block heights.
    // For a consistent set of read values, the DAML Execution Engine should make only a single read request.
    // Later read requests may use block height that is lower than an earlier read request's block height.
    ReadRequest read_request = 1;

    // The result of the pre-execution.
    //
    // The read_set contains all keys that this pre-execution request depends on,
    // along with the fingerprints of the values that were used.
    // Post-execution checks for conflicts on these keys using the fingerprints.
    // Keys are sorted in ascending order.
    //
    // The prexecution_result.output field is a PreExecutionOutput message for DAML pre-execution results.
    //
    // The serialization may only depend on the following inputs:
    // - The key-value-fingerprint triples read during this pre-execution
    // - Key-value-fingerprint triples cached during earlier (pre-)executions
    // - The serialized DAML submission
    // - The submitting participant id
    // In particular, it must not depend on the following:
    // - The replica ID
    com.vmware.concord.PreExecutionResult preexecution_result = 2;
  }

  message ReadRequest {
    // Tag to match with the read request
    // Tags must be unique within the stream of one Preexecute service call.
    string tag = 1;

    // The keys to be read
    repeated bytes keys = 2;
  }
}

message PreExecutionOutput {
  // The time bounds for the record time for the success write set to be written.
  //
  // The DAML Commands Handler checks during post-execution
  // whether the block's summarized time (from the time service)
  // lies within the given bounds (inclusive).
  // If the check fails, the out_of_time_bounds_write_set is written.
  google.protobuf.Timestamp min_record_time = 1;
  google.protobuf.Timestamp max_record_time = 2;

  // The key-value-visibility triples to be written if the record time is within bounds (inclusive).
  // The values in the write set are com.vmware.concord.kvb.ValueWithTrids,
  // which include the visibility information.
  // The write set is shipped in Concord's internal format so that it need not be converted
  // during post-execution. (Post-execution can still extend the write set
  // by adding additional KV pairs.)
  com.vmware.concord.WriteSet success_write_set = 3;

  // The key-value-visibility triples to be written if the record time is outside of the bounds.
  // Same format as for success_write_set.
  com.vmware.concord.WriteSet out_of_time_bounds_write_set = 4;

  // The thin replica clients ids that should learn about the transaction
  // if the success_write_set is written.
  //
  // Post-execution adds a key-value pair with the block's summarized time
  // (= record time) to the write set.
  // This key is visible to the informee_success_thin_replica_ids if the success_write_set is written.
  repeated string informee_success_thin_replica_ids = 5;

  // The block's summarized time is visible to the submitting_participant_id
  // if the out_of_time_bounds_write_set is written.
  //
  // This field is included in the pre-execution output
  // of the DAML Execution Engine
  // so that it makes it to post-execution.
  string submitting_participant_id = 6;
}

// Contents of a time update entry, as expected by participant state reader in Ledger API Server
// for pre-executed submissions.
// Must mirror relevant field numbers from com.daml.ledger.participant.state.kvutils.DamlLogEntry.
message TimeUpdateLogEntry {
  google.protobuf.Timestamp record_time = 1;
  oneof payload {
    google.protobuf.Empty time_update_entry = 101;
  }
}