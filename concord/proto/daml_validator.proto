// Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
//
// DAML submission validation service
//

syntax = "proto3";
package com.digitalasset.kvbc;
option java_package = "com.digitalasset.kvbc";

import "google/protobuf/timestamp.proto";

// The validation service provides a gRPC API taking the `DamlSubmission` message, along
// with the inputs to the submission and returns the resulting fragments and state updates.
service ValidationService {
  // Old interface, but kept until we transition to the pipelined version.
  rpc ValidateSubmission (ValidateRequest) returns (ValidateResponse) {}
  rpc ValidatePendingSubmission (ValidatePendingSubmissionRequest) returns (ValidatePendingSubmissionResponse) {}

  // New pipelined interface
  rpc Validate (stream EventToValidator) returns (stream EventFromValidator) {}
}

message ValidateRequest {
  bytes entry_id = 1;
  bytes submission = 2;
  google.protobuf.Timestamp record_time = 3;
  reserved 4; // was input_state
  string participant_id = 5;

  // The Concord replica that sent this message. Used to maintain separate
  // state caches on the validator for setups that use single validator for multiple
  // replicas (e.g. during development)
  int64 replica_id = 6;
  string correlation_id = 7;
  bytes span_context = 8;
}

message ProtectedKeyValuePair {
  bytes key = 1;
  bytes value = 2;

  // Thin replica ids to which this key-value pair is visible to.
  // If the list is empty, the key-value pair is publicly visible.
  // To only show the key-value pair to replica the list should contain
  // the replica's id.
  // FIXME(JM): What should we use as the replica's id?
  repeated string trids = 3;
}

message Result {
  repeated ProtectedKeyValuePair updates = 1;
  reserved 2; // was state_updates
  repeated bytes read_set = 3;
  google.protobuf.Timestamp max_record_time = 4;
  repeated ProtectedKeyValuePair updates_on_timeout = 5;
  repeated ProtectedKeyValuePair updates_on_conflict = 6;
}


message KeyValuePair {
  bytes key = 1;
  bytes value = 2;
}

message ValidateResponse {
  message NeedState {
    repeated bytes keys = 1;
  }

  oneof response {
    Result result = 1;
    NeedState need_state = 2;
  }
}

message ValidatePendingSubmissionRequest {
  bytes entry_id = 1;
  int64 replica_id = 2;
  repeated KeyValuePair input_state = 3;
  string correlation_id = 4;
  bytes span_context = 5;
}

message ValidatePendingSubmissionResponse {
  Result result = 1;
}


//
// New validator interface
//

// Event sent from the caller (e.g. Concord) towards the validator.
message EventToValidator {
  // A read result is the response to validator's `Read` event.
  message ReadResult {
    // Tag to match with the read event.
    string tag = 1;

    // The read key-value pairs.
    repeated KeyValuePair key_value_pairs = 2;
  }

  oneof to_validator {
    ValidateRequest validate_request = 1;
    ReadResult read_result = 2;
  }
}

// Event from the validator towards the caller.
message EventFromValidator {
  message Read {
    // Tag to match with the read result.
    string tag = 1;

    // Keys to read from KVB.
    repeated bytes keys = 2;
  }

  message Write {
    // Key-value updates to write to KVB. Any subsequent reads should receive
    // these writes.
    repeated ProtectedKeyValuePair updates = 1;
  }

  message Done {
    repeated bytes read_set = 1;
  }

  oneof from_validator {
    // Request to read data from KVB. Client responds with a ReadResult.
    // If an error occurs the client should close the stream to abort
    // the validation.
    Read read = 1;

    // Request to write data to KVB. Client does not respond to this event.
    Write write = 2;

    // Signal that the validation has completed, this is the last event on
    // the stream and it can be closed by the client now.
    Done done = 3;
  }
}


