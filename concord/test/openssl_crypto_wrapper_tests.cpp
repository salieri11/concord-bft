// Copyright 2020 VMware, all rights reserved

#include "gtest/gtest.h"

#include <log4cplus/configurator.h>
#include <log4cplus/hierarchy.h>

#include "utils/openssl_crypto_utils.hpp"

using concord::utils::openssl_crypto::AsymmetricPrivateKey;
using concord::utils::openssl_crypto::AsymmetricPublicKey;
using concord::utils::openssl_crypto::DeserializePrivateKey;
using concord::utils::openssl_crypto::DeserializePublicKey;
using concord::utils::openssl_crypto::GenerateAsymmetricCryptoKeyPair;
using concord::utils::openssl_crypto::kPermittedAsymmetricCryptoSchemes;
using std::invalid_argument;
using std::pair;
using std::string;
using std::unique_ptr;
using std::vector;

namespace {

// Note some of these test cases assume that each key pair generated by
// GenerateAsymmetricCryptoKeyPair will be unique. While the pseudorandom key
// generation process may not actually guarantee this will always be the case,
// the probably of a random key collision should be so low that they will not
// cause noticibale flakiness in this unit testing (and if such collisions are
// noticably frequent, we should scrutinize whether the pseudorandom key
// generation is in fact of cryptographic quality).

const size_t kNumKeyPairsToTryPerCase = 4;
const vector<string> kMessagesToTry(
    {"A", "message", "This message is not random or pseudorandom.", "",
     "The following message will contian information taken from "
     "https://www.random.org.",
     "jSm13lpKQsSYY3o5 QvC2gGLAMVpuLDMO 5S82pwgh2aIeBXqX M4b7RvvRnFhWSDtq "
     "YaF6EIpFZHcrgIgt h4vrEh00JKLTPhQi Ouj46nhAkmGgoa26 y1UKWRKM4T22ZygV "
     "0Ev33yxXLMw2OF5M 6nnvYvtNOuiZgbQ3 cgPzgsyw2jBZGzUh juU97uAzB6qFQbK4 "
     "MFMm3OuW48o0TUbA 5IqzqXYx7H8X1V9v 6OrU65OGVNKnhbuF IargH10iAtVoGYML "
     "zegQbjZZYNl2Jpzt HmNO0Dn18lj7rQPc Jxo1ovjAeGChx2n6 o4QNKPe7aM5MPtae "
     "1J8ZF7S39gAuqNBP 2Rm1vjOKEcNSwp9O aBTVOHdp2tKGmwer rZ14IZU6ZH7Wo7dB "
     "UyZLiXiYJJzqmTbE rxWEr6WEttciAv0Y OZ11VwrFwbNmybSX 661lsE8ScAkjaxha "
     "mtrT0tYEZM93Qm6y LieAqDd047q62pog v9f3buXgWCq8eyuY w3FTB51Jl3GGW9qt "
     "f5Ndarhg2USDQozO Nyy9OOXn54nc7Rwf zUmj4Zhy6cRkVIk1 WnfxOzJV0vVWhjsC "
     "GE6FoDXkXa83B9gk FE58tyErNNXLuMOd Qt8JmPFT70DzPTkB diiqF0n6k4UoYIfS "
     "Nr2no9OU6ZalESHw QOgqolYmaVuvHD3w el9fMRoAthO5ZJau xjZZATDgLCKd3CKx "
     "CHUEffypTqpRaH31 skZV5jKkwy6AwfkO JhIxs7eoqkKQED4P Ux3pQEOqDiTMsFdw"});

TEST(openssl_crypto_wrapper_test, asymmetric_key_generation) {
  // Key generation should fail for an invalid cryptographic scheme.
  EXPECT_THROW(
      GenerateAsymmetricCryptoKeyPair(
          "This string shouldn't match any permitted cryptographic scheme."),
      invalid_argument)
      << "GenerateAsymmetricCryptoKeyPair returned without throwing an "
         "exception when called with a string that shouldn't match a permitted "
         "cryptographic scheme.";

  // There should be a positive number of permitted asymmetric cryptography
  // schemes.
  EXPECT_GT(kPermittedAsymmetricCryptoSchemes.size(), 0)
      << "The OpenSSL Crypto Utilities apparently do not actually permit using "
         "any asymmetric cryptography schemes.";

  // Key generation should not fail for any permitted key type.
  for (const string& scheme : kPermittedAsymmetricCryptoSchemes) {
    pair<unique_ptr<AsymmetricPrivateKey>, unique_ptr<AsymmetricPublicKey>>
        key_pair = GenerateAsymmetricCryptoKeyPair(scheme);
    EXPECT_NE(key_pair.first, nullptr)
        << "GenerateAsymmetricCryptoKeyPair returned a null pointer for the "
           "private key for the allegedly permitted "
        << scheme << " crypto scheme.";
    EXPECT_NE(key_pair.second, nullptr)
        << "GenerateAsymmetricCryptoKeyPair returned a null pointer for the "
           "public key for the allegedly permitted "
        << scheme << " crypto scheme.";
  }
}

TEST(openssl_crypto_wrapper_test, asymmetric_key_compatibility) {
  // A signature made with a private key should be verifiable with the
  // corresponding public key.
  for (const string& scheme : kPermittedAsymmetricCryptoSchemes) {
    for (size_t i = 0; i < kNumKeyPairsToTryPerCase; ++i) {
      pair<unique_ptr<AsymmetricPrivateKey>, unique_ptr<AsymmetricPublicKey>>
          key_pair = GenerateAsymmetricCryptoKeyPair(scheme);
      for (const string& message : kMessagesToTry) {
        EXPECT_TRUE(
            key_pair.second->Verify(message, key_pair.first->Sign(message)))
            << "Under the " << scheme
            << " crypto scheme, an AsymmetricPublicKey failed to validate a "
               "signature produced with the corresponding "
               "AsymmetricPrivateKey.";
      }
    }
  }
}

TEST(openssl_crypto_wrapper_test, asymmetric_key_serialization) {
  // Deserializing serialized keys should return keys equivalent to those that
  // were originally serialized.
  for (const string& scheme : kPermittedAsymmetricCryptoSchemes) {
    for (size_t i = 0; i < kNumKeyPairsToTryPerCase; ++i) {
      pair<unique_ptr<AsymmetricPrivateKey>, unique_ptr<AsymmetricPublicKey>>
          key_pair = GenerateAsymmetricCryptoKeyPair(scheme);
      pair<unique_ptr<AsymmetricPrivateKey>, unique_ptr<AsymmetricPublicKey>>
          serialized_key_pair =
              make_pair(DeserializePrivateKey(key_pair.first->Serialize()),
                        DeserializePublicKey(key_pair.second->Serialize()));
      for (const string& message : kMessagesToTry) {
        EXPECT_TRUE(key_pair.second->Verify(
            message, serialized_key_pair.first->Sign(message)))
            << "Under the " << scheme
            << " crypto scheme, an AsymmetricPublicKey failed to validate a "
               "signature made with an AsymmetricPrivateKey deserialized from "
               "the serialization of the private key that originally matched "
               "that public key.";
        EXPECT_TRUE(serialized_key_pair.second->Verify(
            message, key_pair.first->Sign(message)))
            << "Under the " << scheme
            << " crypto scheme, an AsymmetricPublicKey created by "
               "deserializing a serialized AsymmetricPublicKey failed to "
               "validate a signature made with the private key matching the "
               "original public key object.";
      }
    }
  }

  // Attempting to deserialize from strings not containing well-formed
  // serialized keys should yield an exception.
  EXPECT_THROW(DeserializePrivateKey(""), invalid_argument)
      << "Attempting to deserialize an AsymmetricPrivateKey from an empty "
         "string did not yield an exception.";
  EXPECT_THROW(DeserializePublicKey(""), invalid_argument)
      << "Attempting to deserialize an AsymmetricPublicKey from an empty "
         "string did not yield an exception.";
  EXPECT_THROW(DeserializePrivateKey("This string probably should not be "
                                     "interpretable as a private key for "
                                     "an asymmetric cryptography scheme."),
               invalid_argument)
      << "Attempting to deserialize an AsymmetricPrivateKey from a string that "
         "probably should not be interpretable as a private key did not yeild "
         "an exception.";
  EXPECT_THROW(DeserializePublicKey("This string probably should not be "
                                    "interpreetable as a public key for "
                                    "an asymmetric cryptography scheme."),
               invalid_argument)
      << "Attempting to deserialize an AsymmetricPublicKey from a string that "
         "probably should not be interpretable as a public key did not yeild "
         "an exception.";
}

TEST(openssl_crypto_wrapper_test, asymmetric_key_signature_verification) {
  // A public key should fail to verify signatures produced with non-matching
  // public keys.
  for (const string& scheme : kPermittedAsymmetricCryptoSchemes) {
    vector<
        pair<unique_ptr<AsymmetricPrivateKey>, unique_ptr<AsymmetricPublicKey>>>
        key_pairs;
    for (size_t i = 0; i < kNumKeyPairsToTryPerCase; ++i) {
      key_pairs.push_back(GenerateAsymmetricCryptoKeyPair(scheme));
    }
    for (size_t i = 0; i < kNumKeyPairsToTryPerCase; ++i) {
      for (size_t j = 0; j < kNumKeyPairsToTryPerCase; ++j) {
        if (i != j) {
          for (const string& message : kMessagesToTry) {
            EXPECT_FALSE(key_pairs[j].second->Verify(
                message, key_pairs[i].first->Sign(message)))
                << "Under the " << scheme
                << " crypto scheme, an AsymmetricPublicKey found a signature "
                   "produced with a non-matching AsymmetricPrivateKey to be "
                   "valid.";
          }
        }
      }
    }
  }

  // A public key should fail to verify a signature produced with the
  // corresponding private key when the message to be verified does not match
  // the message that was signed.
  for (const string& scheme : kPermittedAsymmetricCryptoSchemes) {
    for (size_t i = 0; i < kNumKeyPairsToTryPerCase; ++i) {
      pair<unique_ptr<AsymmetricPrivateKey>, unique_ptr<AsymmetricPublicKey>>
          key_pair = GenerateAsymmetricCryptoKeyPair(scheme);
      for (const string& message : kMessagesToTry) {
        for (const string& different_message : kMessagesToTry) {
          if (message != different_message) {
            EXPECT_FALSE(key_pair.second->Verify(different_message,
                                                 key_pair.first->Sign(message)))
                << "Under the " << scheme
                << " crypto scheme, an AsymmetricPublicKey found a signature "
                   "signed by a matching AsymmetricPrivateKey to be valid for "
                   "a different message than the one that was signed.";
          }
        }
      }
    }
  }

  // A public key should fail to verify a signature if it is given a malformed
  // signature.
  for (const string& scheme : kPermittedAsymmetricCryptoSchemes) {
    for (size_t i = 0; i < kNumKeyPairsToTryPerCase; ++i) {
      pair<unique_ptr<AsymmetricPrivateKey>, unique_ptr<AsymmetricPublicKey>>
          key_pair = GenerateAsymmetricCryptoKeyPair(scheme);
      for (const string& message : kMessagesToTry) {
        EXPECT_FALSE(key_pair.second->Verify(message, ""))
            << "Under the " << scheme
            << " crypto scheme, an AsymmetricPublicKey found an empty string "
               "to be a valid signature for a message.";
        EXPECT_FALSE(key_pair.second->Verify(
            message, "This should not be a valid signature."))
            << "Under the " << scheme
            << " crypto scheme, an AsymmetricPublicKey found a string that "
               "should not be a valid signature to be a valid signature for a "
               "message.";
      }
    }
  }
}
}  // anonymous namespace

int main(int argc, char** argv) {
  ::testing::InitGoogleTest(&argc, argv);

  // log4cplus configuration
  log4cplus::initialize();
  auto& hierarchy = log4cplus::Logger::getDefaultHierarchy();
  hierarchy.disableDebug();
  log4cplus::BasicConfigurator config{hierarchy, false};
  config.configure();

  return RUN_ALL_TESTS();
}
