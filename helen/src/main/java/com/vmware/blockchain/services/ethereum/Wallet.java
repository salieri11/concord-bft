/*
 * Copyright (c) 2018-2019 VMware, Inc. All rights reserved. VMware Confidential
 */

package com.vmware.blockchain.services.ethereum;

import java.math.BigInteger;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.Security;
import java.security.spec.ECGenParameterSpec;
import java.util.Arrays;
import java.util.UUID;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

import org.bouncycastle.crypto.generators.SCrypt;
import org.bouncycastle.jcajce.provider.asymmetric.ec.BCECPrivateKey;
import org.bouncycastle.jcajce.provider.asymmetric.ec.BCECPublicKey;
import org.bouncycastle.jcajce.provider.digest.Keccak;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.bouncycastle.util.encoders.Hex;
import org.json.simple.JSONObject;

import com.vmware.blockchain.common.ErrorCodeType;
import com.vmware.blockchain.common.WalletException;


/**
 * Ethereum compatible wallet, which is describe in details at
 * https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition
 */
public class Wallet {

    private static final SecureRandom secureRandom = new SecureRandom();

    // Iteration count. Defaults to 262144 for geth
    private static final int N_STANDARD = 1 << 18;

    // Parallelization factor. Defaults to 1
    private static final int P_STANDARD = 1;

    // Block size for the underlying hash. Defaults to 8
    private static final int R = 8;

    // Derived key length (in bytes)
    private static final int DKLEN = 32;

    // wallet version
    private static final int CURRENT_VERSION = 3;

    public static final int PRIVATE_KEY_SIZE = 32;
    public static final int ADDRESS_LENGTH_IN_HEX = 40;

    // The cipher to use, Names must match those of supported by OpenSSL,
    // e.g. aes-128-ctr or aes-128-cbc.
    private static final String CIPHER = "aes-128-ctr";

    // The key derivation function
    private static final String SCRYPT = "scrypt";

    static {
        if (Security.getProvider(BouncyCastleProvider.PROVIDER_NAME) == null) {
            Security.addProvider(new BouncyCastleProvider());
        }
    }

    /**
     * Create new wallet with password.
     * @param password password used to create the wallet
     * @return wallet in json format
     * @throws Exception any exception during create wallet
     */
    public static JSONObject createWallet(String password) throws Exception {
        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("ECDSA", "BC");
        ECGenParameterSpec ecGenParameterSpec = new ECGenParameterSpec("secp256k1");
        keyPairGenerator.initialize(ecGenParameterSpec, secureRandom);
        KeyPair keyPair = keyPairGenerator.generateKeyPair();

        byte[] salt = generateRandomBytes(32);
        byte[] derivedKey = SCrypt.generate(password.getBytes("UTF-8"), salt, N_STANDARD, R, P_STANDARD, DKLEN);
        byte[] encryptKey = Arrays.copyOfRange(derivedKey, 0, 16);
        byte[] iv = generateRandomBytes(16);
        BCECPrivateKey privateKey = (BCECPrivateKey) keyPair.getPrivate();
        byte[] privateKeyBytes = toBytesPadded(privateKey.getD(), PRIVATE_KEY_SIZE);
        final byte[] cipherText = performCipherOperation(
                Cipher.ENCRYPT_MODE, iv, encryptKey, privateKeyBytes);
        final byte[] mac = generateMac(derivedKey, cipherText);
        String address = getAddress(keyPair);

        JSONObject wallet = new JSONObject();
        wallet.put("address", address);
        wallet.put("id", UUID.randomUUID().toString());
        wallet.put("version", CURRENT_VERSION);
        JSONObject crypto = new JSONObject();
        crypto.put("cipher", CIPHER);
        crypto.put("ciphertext", Hex.toHexString(cipherText));
        JSONObject cipherparams = new JSONObject();
        cipherparams.put("iv", Hex.toHexString(iv));
        crypto.put("cipherparams", cipherparams);
        crypto.put("kdf", SCRYPT);
        JSONObject kdfparams = new JSONObject();
        kdfparams.put("dklen", DKLEN);
        kdfparams.put("n", N_STANDARD);
        kdfparams.put("p", P_STANDARD);
        kdfparams.put("r", R);
        kdfparams.put("salt", Hex.toHexString(salt));
        crypto.put("kdfparams", kdfparams);
        crypto.put("mac", Hex.toHexString(mac));
        wallet.put("crypto", crypto);

        return wallet;
    }

    /**
     * Generate random bytes with specific size.
     * @param size size of generated bytes
     * @return generated random bytes
     */
    public static byte[] generateRandomBytes(int size) {
        byte[] bytes = new byte[size];
        secureRandom.nextBytes(bytes);
        return bytes;
    }

    /**
     * pad the input to specific length.
     * @param value input data
     * @param length desired length
     * @return padded bytes
     */
    public static byte[] toBytesPadded(BigInteger value, int length) throws WalletException {
        byte[] result = new byte[length];
        byte[] bytes = value.toByteArray();

        int bytesLength;
        int srcOffset;
        // when converting priavteKey (bigInteger) to bytes array, it will lead
        // to 33 bytes (with leading byte as 0) sometimes, hence it needed to be
        // trimmed.
        if (bytes[0] == 0) {
            bytesLength = bytes.length - 1;
            srcOffset = 1;
        } else {
            bytesLength = bytes.length;
            srcOffset = 0;
        }

        if (bytesLength > length) {
            throw new WalletException(ErrorCodeType.INVALID_INPUT_SIZE.getErrorCodeTypeValue() + length);
        }

        int destOffset = length - bytesLength;
        System.arraycopy(bytes, srcOffset, result, destOffset, bytesLength);
        return result;
    }

    private static byte[] performCipherOperation(
            int mode,
            byte[] iv,
            byte[] encryptKey,
            byte[] text)
            throws NoSuchPaddingException,
                   NoSuchAlgorithmException,
                   InvalidAlgorithmParameterException,
                   InvalidKeyException,
                   BadPaddingException,
                   IllegalBlockSizeException {
        IvParameterSpec ivParameterSpec = new IvParameterSpec(iv);
        Cipher cipher = Cipher.getInstance("AES/CTR/NoPadding");

        SecretKeySpec secretKeySpec = new SecretKeySpec(encryptKey, "AES");
        cipher.init(mode, secretKeySpec, ivParameterSpec);
        return cipher.doFinal(text);
    }

    private static byte[] generateMac(byte[] derivedKey, byte[] cipherText) {
        byte[] result = new byte[16 + cipherText.length];
        System.arraycopy(derivedKey, 16, result, 0, 16);
        System.arraycopy(cipherText, 0, result, 16, cipherText.length);
        return sha3(result);
    }

    /**
     * Keccak256 hash.
     * @param input message to be hashed
     * @return hkeccak256 hash
     */
    public static byte[] sha3(byte[] input) {
        Keccak.DigestKeccak kecc = new Keccak.Digest256();
        kecc.update(input, 0, input.length);
        return kecc.digest();
    }

    /**
     * generate wallet address with public key.
     * @param keyPair keypair which including the public key
     * @return address in hex, no leading '0x'
     */
    public static String getAddress(KeyPair keyPair) {
        BCECPublicKey publicKey = (BCECPublicKey) keyPair.getPublic();
        byte[] publicKeyBytes = publicKey.getQ().getEncoded(false);
        // As the first byte is constantly "0x04", ignore it as Ethereum
        String hash = Hex.toHexString(sha3(Arrays.copyOfRange(publicKeyBytes, 1, publicKeyBytes.length)));
        return hash.substring(hash.length() - ADDRESS_LENGTH_IN_HEX);
    }
}
