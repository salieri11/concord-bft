#########################################################################
# Copyright 2020 VMware, Inc.  All rights reserved. -- VMware Confidential
#########################################################################

import pytest

from suites.case import describe

from fixtures.common_fixtures import fxBlockchain, fxConnection, fxInitializeOrgs, fxProduct
import util.auth
import util.helen.common
import util.helen.error_codes
import util.helen.validators
import util.helen.zone
import util.helper
import util.product


defaultTokenDescriptor = util.auth.getTokenDescriptor(util.auth.ROLE_CON_ADMIN,
                                                      True,
                                                      util.auth.internal_admin)

#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
# HELEN BLOCKCHAIN TESTS
#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

@describe()
@pytest.mark.smoke
@pytest.mark.foo
@pytest.mark.blockchains
@pytest.mark.smoke
def test_blockchains_one(fxConnection):
    '''
    Test with one blockchain deployed, which is the default.
    '''
    blockchains = fxConnection.request.getBlockchains()
    assert len(blockchains) == 1, "Expected one blockchain to be returned"
    blockchain = blockchains[0]
    util.helen.validators.validateBlockchainFields(blockchain)


@describe()
@pytest.mark.smoke
@pytest.mark.blockchains
def test_getABlockchain_valid(fxConnection):
    '''
    Test GET /blockchains/{bid}, which gets details for a given blockchain.
    '''
    blockchainId = fxConnection.request.getBlockchains()[0]["id"]
    blockchain = fxConnection.request.getBlockchainDetails(blockchainId)
    util.helen.validators.validateBlockchainFields(blockchain)


@describe()
@pytest.mark.smoke
@pytest.mark.blockchains
def test_getABlockhain_invalid_uuid(fxConnection):
    '''
    Test GET /blockchains/{bid} with a UUID that is already used.
    This test's UUID was generated by Helen once, so the test *should*
    pass for a billion or more years.  Willing to accept the risk.
    '''
    blockchainId = "8fecf880-26e3-4d71-9778-ad1592324684"
    response = fxConnection.request.getBlockchainDetails(blockchainId)
    expectedPath = "/api/blockchains/{}".format(blockchainId)
    expectedMessage = util.helen.error_codes.BLOCKCHAIN_NOT_FOUND.format(blockchainId)
    util.helen.validators.validateNotFound(response,
                                           expectedPath = expectedPath,
                                           errorCode = "NotFoundException",
                                           testErrorMessage = True,
                                           errorMessage = expectedMessage)


@describe()
@pytest.mark.smoke
def test_getABlockhain_invalid_uuid_format(fxConnection):
    '''
    Test GET /blockchains/{bid} with an invalid uuid format.
    '''
    blockchainId = "3"
    response = fxConnection.request.getBlockchainDetails(blockchainId)
    util.helen.validators.validateBadRequest(response, "/api/blockchains/{}".format(blockchainId),
                                             errorCode="MethodArgumentTypeMismatchException",
                                             errorMessage="Failed to convert value of type " \
                                                          "'java.lang.String' to required type 'java.util.UUID'; " \
                                                          "nested exception is java.lang.IllegalArgumentException: " \
                                                          "Invalid UUID string: 3")


@describe()
@pytest.mark.skip(reason="Need Hermes ability to stop/start the product.")
def test_blockchains_none(fxConnection, fxHermesRunSettings):
    '''
    How to start the product with no blockchains?
    Filed VB-841: Not able to start Helen with no blockchains.
    '''
    # restartTheProductWithNoBlockchains()
    product = util.product.Product(hermesArgs,
                                   fxHermesRunSettings["hermesUserConfig"])
    product.stopProduct()
    util.helper.setHelenProperty("vmbc.default.blockchain", "false")

    # Something goes wrong launching the product.  This is not a super high priority
    # test case because it will only be possible in the product the first time it is
    # ever launched.  Come back to it.
    product.launchProduct()
    blockchains = fxConnection.request.getBlockchains()
    assert len(blockchains) == 0, "Expected zero blockchains to be returned"

    # Clean up
    product.stopProduct()
    util.helper.setHelenProperty("vmbc.default.blockchain", "true")
    product.launchProduct()


@describe()
@pytest.mark.skip(reason="Waiting for blockchain deletion capability")
def test_blockchains_multiple(fxConnection):
    '''
    Ensure > 1 blockchains, and be sure they are really different.
    '''
    # while len(fxConnection.request.getBlockchains()) < 2:
    #    addAnotherBlockchain()
    #
    # beSureTheBlockchainsAreDifferentAndUsingDifferentConcordNodes()
    #
    # for blockchain in fxConnection.request.getBlockchains():
    #    verifyBlockchainFields(fxConnection.request, blockchain)
    pass

@pytest.mark.smoke
@pytest.mark.blockchains
def test_invalid_blockchain_post(fxConnection):
    '''
    Blockchain creation test with bad parameters.
    '''
    req = fxConnection.request.newWithToken(defaultTokenDescriptor)

    zoneList = []

    for _ in range(0,4):
        zoneInfo = util.helen.zone.createZoneObject()
        req = util.helen.common.createDefaultConsortiumAdminRequest(fxConnection.request)
        response = req.createZone(zoneInfo)
        zoneList.append(response["id"])

    blockchain_task_response = req.createBlockchain("", zoneList)

    util.helen.validators.validateBadRequest(blockchain_task_response, "/api/blockchains",
                                             "MethodArgumentNotValidException", False)
